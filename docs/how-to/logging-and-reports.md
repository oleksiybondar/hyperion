# 4.15 Logging and Reporting

---

← [Back to Documentation Index](/docs/index.md)  
← Previous: [Elements Query Language (EQL) Recipes](/docs/how-to/eql-recipes.md)  
→ Next: [Component: RadioGroup](/docs/how-to/radiogroup.md)

---

This guide explains **how to read Hyperion’s HTML logs** for fast debugging.

It focuses on **automatic logging** generated by Hyperion:
- test boundaries and fixture structure
- page/widget/iframe/webview flow boundaries
- element paths and resolution steps
- `expect` vs `verify` outcomes (same format, different log levels)
- backend/tool messages (e.g., Selenium/Appium internal logs)

You *can* add your own messages, but that is not the focus here.

---

## How the HTML report is built

Hyperion writes the log as **NDJSON** (newline-delimited JSON).  
In the HTML report it is embedded in the page as hidden data, for example:

- `<div class="hidden" id="ndjson-data"> ... </div>`

A small client-side script renders this NDJSON into a searchable, filterable UI.

Practical takeaway:
- **everything is logged**, even if it is currently hidden by filters
- the UI decides what to show (by source, level, content type)

---

## The report layout at a glance

A typical report page contains:

1. **Test metadata header**
   - test name, tags, status, duration

2. **Filters control panel**
   - source filters (“sender”)
   - log level filters
   - content toggles (backtrace, screen snap, page source)
   - column toggles

3. **Log lines timeline**
   - timestamped, categorized entries
   - expandable/collapsible messages
   - optional link to source code (when enabled)

---

## Step 1: Start with the test header

At the top you will see fields like:

- **Test name**
- **Test tags**
- **Status**
- **Duration**

Tags help you quickly identify the domain and intent of the test.
For example, an EQL test may include tags such as:
`ElementsQueryLanguage`, `text`, `MultipleElement`.

---

## Step 2: Understand “sources” (senders)

Every log line is categorized by **source** (sender).  
The report provides quick source filters such as:

- **Test Case**
- **Web Page**
- **Element**
- **Expect**
- (and potentially others depending on the backend and adapters)

Use source filters to reduce noise:

- **Web Page**: browser/app lifecycle, navigation, context boundaries
- **Element**: locating, interacting, reading values (text, attributes, etc.)
- **Expect / Verify**: evaluation results (assertion-like output)
- **Test Case**: lifecycle boundaries, hooks, duration/status

Some automation backends (e.g., Selenium/Appium) may also inject their own debug output.
These entries are part of the same NDJSON stream and can be filtered like any other source.

---

## Step 3: Use log levels intentionally

Hyperion’s log UI supports level filters such as:

- Debug
- Info
- Warning
- Error
- Fatal
- Assertion (a special marker)

Important rule:

> `expect` and `verify` are logged in the **same format**,  
> but typically at **different levels**.

So when debugging a branching flow or EQL selection:
- enable **Debug** to see decision traces
- keep **Info + Assertion** enabled to follow the main story

---

## Step 4: Read element paths like a stack trace

Element logs include **structured paths** that reflect your Page Object hierarchy.

Example pattern:

- `[BasicElementsSearch.multiple_elements] Searching element by By.css selector(...)`
- `[BasicElementsSearch.multiple_elements] 3 elements found`
- `[BasicElementsSearch.multiple_elements[1]] getting element's text: ...`

These paths are one of the main reasons hierarchical modeling pays off:
- you can infer **where** the framework is acting
- you can correlate failures to the logical UI model, not raw selectors

When something fails:
1. find the failing assertion
2. scroll slightly upward
3. read the nearest element path entries
4. you usually get both:
   - what was searched
   - how many matches were found
   - what content was read

---

## Step 5: Interpreting `expect` and assertion markers

In the rendered UI, `expect` entries often appear as:

- source: **Expect**
- an **assertion marker** (e.g., “assert-true”)
- a message containing:
  - assertion description
  - pass/fail status
  - actual value (and expected value when relevant)

Example (pass):

- `[Expect] ... assertion Pass.`
- `Actual value: ...`

When a test fails, start here:
- filter to **Expect**
- keep **Assertion** enabled
- locate the first failing assertion entry
- expand the message if needed

This is the fastest route to the cause of failure.

---

## Step 6: Debugging decisions (Verify and EQL)

Decision-heavy flows (A/B branches, optional UI, EQL selection) depend on **decision logging**.

What to do when selection/branching is unclear:

1. Enable **Debug** level
2. Filter by relevant sources:
   - **Element** (reads and comparisons)
   - **Expect / Verify** (evaluation results)
3. Look for repeated “probe” patterns:
   - reading candidate text/attribute/style
   - comparing against expected values
   - continuing to the next candidate

This is where Hyperion’s logs shine:
- you do not lose “why” information
- you can see what was observed at decision points
- you can reconstruct selection logic without inspecting DOM manually

---

## Step 7: Use the content toggles when needed

The report UI typically includes content toggles such as:

- **Backtrace**
- **Screen Snap**
- **Page Source**

Keep them off for normal reading.
Enable them when you need more context:
- a failure is hard to reproduce
- UI state matters (visibility/layout)
- you suspect wrong page/context

---

## Recommended debugging workflow

When a test fails:

1. Look at **Status** and **Duration** in the header
2. Filter to **Expect** and **Assertion**
3. Find the **first failure**
4. Read **upward** to see:
   - element resolution attempts
   - values read
   - navigation/context events
5. If a decision is involved:
   - enable **Debug**
   - inspect verify/EQL traces
6. Only then open:
   - backtrace
   - screenshots
   - page source

This keeps debugging fast and prevents “log scrolling fatigue”.

---

## What you learned

You now know how to:
- interpret sources and log levels
- use assertions as the primary entry point
- read element paths as structured context
- debug decisions using debug-level traces
- use content toggles only when necessary

---

## Next steps

If you are debugging selection-heavy tests, also see:

- [/docs/how-to/eql-recipes.md](/docs/how-to/eql-recipes.md)
- [/docs/tutorials/expect-vs-verify.md](/docs/tutorials/expect-vs-verify.md)

---

← [Back to Documentation Index](/docs/index.md)  
← Previous: [Elements Query Language (EQL) Recipes](/docs/how-to/eql-recipes.md)  
→ Next: [Component: RadioGroup](/docs/how-to/radiogroup.md)
